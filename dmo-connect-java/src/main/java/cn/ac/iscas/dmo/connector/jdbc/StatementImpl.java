package cn.ac.iscas.dmo.connector.jdbc;

import cn.ac.iscas.dmo.connector.jdbc.statement.ExecuteQuery;
import cn.ac.iscas.dmo.connector.jdbc.statement.ExecuteUpdate;
import com.alibaba.druid.DbType;
import com.alibaba.druid.sql.SQLUtils;
import com.alibaba.druid.sql.ast.SQLStatement;
import com.alibaba.druid.sql.ast.statement.*;
import com.alibaba.druid.sql.dialect.mysql.ast.statement.*;
import com.alibaba.druid.sql.dialect.odps.ast.*;
import com.alibaba.druid.sql.dialect.oracle.ast.stmt.OracleExplainStatement;
import com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarSelectStatement;
import com.alibaba.druid.sql.dialect.oscar.ast.stmt.OscarShowStatement;
import com.alibaba.druid.sql.dialect.postgresql.ast.stmt.PGShowStatement;
import com.alibaba.druid.sql.dialect.presto.ast.stmt.PrestoSelectStatement;

import java.io.IOException;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

/**
 * @author zhuquanwen
 * @version 1.0
 * @date 2024/9/23 14:25
 */

public class StatementImpl implements DmoStatement {
    private final ConnectionImpl connection;
    private final List<String> batchSqls = new ArrayList<>();

    private int resultSetType;
    private int resultSetConcurrency;
    private ResultSet rs;
    private int updateCount = 0;
    private int fetchSize = 1000;
    private int autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;

    private boolean closed = false;

    public StatementImpl(ConnectionImpl connection) {
        this.connection = connection;
    }

    private static final Class[] SELECT_STATEMENTS = new Class[]{CobarShowStatus.class, DrdsBaselineStatement.class,
            DrdsShowDDLJobs.class, DrdsShowGlobalIndex.class, DrdsShowMetadataLock.class,
            MysqlShowCreateFullTextStatement.class, MysqlShowFullTextStatement.class, MysqlShowCreateFullTextStatement.class,
            MysqlShowDbLockStatement.class, MysqlShowHtcStatement.class, MysqlShowStcStatement.class,
            MySqlShowAuthorsStatement.class, MySqlExplainPlanCacheStatement.class, MySqlExplainStatement.class,
            MySqlHelpStatement.class, MySqlHintStatement.class, MySqlShowAuthorsStatement.class,
            MySqlShowBinLogEventsStatement.class, MySqlShowBinaryLogsStatement.class, MySqlShowBroadcastsStatement.class,
            MySqlShowCharacterSetStatement.class, MySqlShowClusterNameStatement.class, MySqlShowCollationStatement.class,
            MySqlShowConfigStatement.class, MySqlShowConfigStatement.class, MySqlShowContributorsStatement.class,
            MySqlShowCreateDatabaseStatement.class, MySqlShowCreateEventStatement.class, MySqlShowCreateFunctionStatement.class,
            MySqlShowCreateProcedureStatement.class, MySqlShowCreateTriggerStatement.class, MySqlShowDatabaseStatusStatement.class,
            MySqlShowDatasourcesStatement.class, MySqlShowDdlStatusStatement.class, MySqlShowDsStatement.class,
            MySqlShowEngineStatement.class, MySqlShowEnginesStatement.class, MySqlShowErrorsStatement.class,
            MySqlShowEventsStatement.class, MySqlShowFunctionCodeStatement.class, MySqlShowFunctionStatusStatement.class,
            MySqlShowGrantsStatement.class, MySqlShowHMSMetaStatement.class, MySqlShowHelpStatement.class,
            MySqlShowJobStatusStatement.class, MySqlShowMasterLogsStatement.class, MySqlShowMasterStatusStatement.class,
            MySqlShowMigrateTaskStatusStatement.class, MySqlShowNodeStatement.class, MySqlShowOpenTablesStatement.class,
            MySqlShowPartitionsStatement.class, MySqlShowPhysicalProcesslistStatement.class, MySqlShowPlanCacheStatement.class,
            MySqlShowPlanCacheStatusStatement.class, MySqlShowPluginsStatement.class, MySqlShowPrivilegesStatement.class,
            MySqlShowProcedureCodeStatement.class, MySqlShowProcedureStatusStatement.class, MySqlShowProcessListStatement.class,
            MySqlShowProfileStatement.class, MySqlShowProfilesStatement.class, MySqlShowRelayLogEventsStatement.class,
            MySqlShowRuleStatement.class, MySqlShowRuleStatusStatement.class, MySqlShowSequencesStatement.class,
            MySqlShowSlaveHostsStatement.class, MySqlShowSlaveStatusStatement.class, MySqlShowSlowStatement.class,
            MySqlShowStatement.class, MySqlShowStatusStatement.class, MySqlShowTableStatusStatement.class,
            MySqlShowTopologyStatement.class, MySqlShowTraceStatement.class, MySqlShowTriggersStatement.class,
            MySqlShowWarningsStatement.class, MysqlShowCreateFullTextStatement.class, MysqlShowDbLockStatement.class,
            MysqlShowFullTextStatement.class, MysqlShowHtcStatement.class, MysqlShowStcStatement.class,
            OdpsCountStatement.class, OdpsListStmt.class, OdpsQueryAliasStatement.class, OdpsReadStatement.class,
            OdpsShowChangelogsStatement.class, OdpsShowGrantsStmt.class, OracleExplainStatement.class,
            OscarSelectStatement.class, OscarShowStatement.class, PGShowStatement.class, PrestoSelectStatement.class,
            SQLAnalyzeTableStatement.class, SQLDescribeStatement.class, SQLExplainAnalyzeStatement.class,
            SQLExplainStatement.class, SQLListResourceGroupStatement.class, SQLOptimizeStatement.class,
            SQLSelectStatement.class, SQLShowACLStatement.class, SQLShowCatalogsStatement.class,
            SQLShowColumnsStatement.class, SQLShowCreateMaterializedViewStatement.class, SQLShowCreateTableStatement.class,
            SQLShowCreateViewStatement.class, SQLShowDatabasesStatement.class, SQLShowErrorsStatement.class,
            SQLShowFunctionsStatement.class, SQLShowGrantsStatement.class, SQLShowHistoryStatement.class,
            SQLShowIndexesStatement.class, SQLShowMaterializedViewStatement.class, SQLShowOutlinesStatement.class,
            SQLShowPackagesStatement.class, SQLShowPartitionsStmt.class, SQLShowProcessListStatement.class,
            SQLShowPartitionsStmt.class, SQLShowProcessListStatement.class, SQLShowQueryTaskStatement.class,
            SQLShowRecylebinStatement.class, SQLShowRoleStatement.class, SQLShowRolesStatement.class,
            SQLShowSessionStatement.class, SQLShowStatement.class, SQLShowStatisticStmt.class,
            SQLShowStatisticListStmt.class, SQLShowTableGroupsStatement.class, SQLShowTablesStatement.class,
            SQLShowUsersStatement.class, SQLShowVariantsStatement.class, SQLShowViewsStatement.class,
    };


    @Override
    public ResultSet executeQuery(String sql) throws SQLException {
        checkClosed();
        ResultSetImpl rs = initRs();
        rs.setFetchSize(getFetchSize());
        try {
            ExecuteQuery.execute(rs, sql);
        } catch (IOException e) {
            throw new SQLException("从数据中台查询数据出错:" + e.getMessage(), e);
        }
        return rs;
    }

    @Override
    public int executeUpdate(String sql) throws SQLException {
        try {
            return ExecuteUpdate.execute(this.connection, sql);
        } catch (IOException e) {
            throw new RuntimeException("修改数据出错:" + e.getMessage(), e);
        }
    }

    @Override
    public void close() throws SQLException {
        closed = true;
    }

    @Override
    public int getMaxFieldSize() throws SQLException {
        return 0;
    }

    @Override
    public void setMaxFieldSize(int max) throws SQLException {

    }

    @Override
    public int getMaxRows() throws SQLException {
        return 0;
    }

    @Override
    public void setMaxRows(int max) throws SQLException {

    }

    @Override
    public void setEscapeProcessing(boolean enable) throws SQLException {

    }

    @Override
    public int getQueryTimeout() throws SQLException {
        return 0;
    }

    @Override
    public void setQueryTimeout(int seconds) throws SQLException {

    }

    @Override
    public void cancel() throws SQLException {

    }

    @Override
    public SQLWarning getWarnings() throws SQLException {
        return null;
    }

    @Override
    public void clearWarnings() throws SQLException {

    }

    @Override
    public void setCursorName(String name) throws SQLException {

    }

    @Override
    public boolean execute(String sql) throws SQLException {
        checkClosed();
//        try {
        String datasourceType = connection.getDatasourceType();
        // 不知道什么原因，出现full时解析就会出错，这里暂时做一下处理，todo
        String checkSql = sql.replace("full,", "full1,");

        DbType dbType = DbType.mysql;
        if (datasourceType.startsWith("mysql")) {
            dbType = DbType.mysql;
        } else if (datasourceType.startsWith("oracle")) {
            dbType = DbType.oracle;
        } else if (datasourceType.startsWith("postgresql")) {
            dbType = DbType.postgresql;
        } else if (datasourceType.startsWith("dameng")) {
            dbType = DbType.dm;
        } else if (datasourceType.startsWith("tdengine")) {
            dbType = DbType.taosdata;
        }
        List<SQLStatement> statementList = SQLUtils.parseStatements(checkSql, dbType);
        if (statementList != null && statementList.size() > 0 && isSelect(statementList.get(0), checkSql, dbType)) {
            rs = executeQuery(sql);
            return true;
        } else {
            updateCount = executeUpdate(sql);
            return false;
        }
//        } catch (JSQLParserException e) {
//            throw new SQLException("SQL解析出错", e);
//        }
    }

    private boolean isSelect(SQLStatement statement, String checkSql, DbType dbType) {
        if (DbType.mysql == dbType || checkSql.toLowerCase().contains("select @@identity")) {
            return true;
        }

        for (Class selectStatement : SELECT_STATEMENTS) {
            if (statement.getClass() == selectStatement) {
                return true;
            }
        }
        return false;
    }

    @Override
    public ResultSet getResultSet() throws SQLException {
        return rs;
    }

    @Override
    public int getUpdateCount() throws SQLException {
        return updateCount;
    }

    @Override
    public boolean getMoreResults() throws SQLException {
        return false;
    }

    @Override
    public void setFetchDirection(int direction) throws SQLException {

    }

    @Override
    public int getFetchDirection() throws SQLException {
        return 0;
    }

    @Override
    public void setFetchSize(int rows) throws SQLException {
        this.fetchSize = rows;
    }

    @Override
    public int getFetchSize() throws SQLException {
        return fetchSize;
    }

    @Override
    public int getResultSetConcurrency() throws SQLException {
        return ResultSet.CONCUR_READ_ONLY;
    }

    @Override
    public int getResultSetType() throws SQLException {
        return ResultSet.FETCH_FORWARD;
    }

    @Override
    public void addBatch(String sql) throws SQLException {
        batchSqls.add(sql);
    }

    @Override
    public void clearBatch() throws SQLException {
        batchSqls.clear();
    }

    @Override
    public int[] executeBatch() throws SQLException {
        checkClosed();
        int[] res = new int[batchSqls.size()];
        for (int i = 0; i < batchSqls.size(); i++) {
            res[i] = executeUpdate(batchSqls.get(i));
        }
        return res;
    }

    @Override
    public Connection getConnection() throws SQLException {
        return connection;
    }

    @Override
    public boolean getMoreResults(int current) throws SQLException {
        return false;
    }

    @Override
    public ResultSet getGeneratedKeys() throws SQLException {
        checkClosed();
        if (RETURN_GENERATED_KEYS == autoGeneratedKeys) {
//            ResultSetImpl rs = new ResultSetImpl(this);
//            if (CollectionUtils.isNotEmpty(dsIds)) {
//                List<Map<String, Object>> data = dsIds.stream().map(id -> {
//                    Map<String, Object> header = new HashMap<>(1);
//                    header.put("_id", id);
//                    return header;
//                }).toList();
//                rs.setCacheData(data);
//            }
//            rs.setHeaderMapping(new HashMap<>(1){{put(0, "_id");}});
//            return rs;
            // todo
            return rs;
        }
        return null;
    }

    @Override
    public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {
        checkClosed();
        this.autoGeneratedKeys = autoGeneratedKeys;
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, int[] columnIndexes) throws SQLException {
        // todo 暂不处理columnIndexes
        return executeUpdate(sql);
    }

    @Override
    public int executeUpdate(String sql, String[] columnNames) throws SQLException {
        // todo 暂不处理columnNames
        return executeUpdate(sql);
    }

    @Override
    public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {
        checkClosed();
        this.autoGeneratedKeys = autoGeneratedKeys;
        return execute(sql);
    }

    @Override
    public boolean execute(String sql, int[] columnIndexes) throws SQLException {
        // todo 暂不处理columnIndexes
        return execute(sql);
    }

    @Override
    public boolean execute(String sql, String[] columnNames) throws SQLException {
        // todo 暂不处理columnNames
        return execute(sql);
    }

    @Override
    public int getResultSetHoldability() throws SQLException {
        return 0;
    }

    @Override
    public boolean isClosed() throws SQLException {
        return closed;
    }

    @Override
    public void setPoolable(boolean poolable) throws SQLException {

    }

    @Override
    public boolean isPoolable() throws SQLException {
        return false;
    }

    @Override
    public void closeOnCompletion() throws SQLException {

    }

    @Override
    public boolean isCloseOnCompletion() throws SQLException {
        return isClosed();
    }

    @Override
    public <T> T unwrap(Class<T> iface) throws SQLException {
        return null;
    }

    @Override
    public boolean isWrapperFor(Class<?> iface) throws SQLException {
        return false;
    }


    private void checkClosed() throws SQLException {
        if (closed) {
            throw new SQLException("statement已关闭");
        }
    }

    private ResultSetImpl initRs() {
        return new ResultSetImpl(this);
    }


    public void setResultSetType(int resultSetType) {
        this.resultSetType = resultSetType;
    }

    public void setResultSetConcurrency(int resultSetConcurrency) {
        this.resultSetConcurrency = resultSetConcurrency;
    }
}
